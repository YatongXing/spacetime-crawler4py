<!-- URL: http://www.ics.uci.edu/~eppstein/pubs/kbest.html -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head>
<title>David Eppstein - Publications</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll("script[type='math/tex']").forEach(function(el) {
              el.outerHTML = "\\(" + el.textContent + "\\)";
            });
            document.querySelectorAll("script[type='math/tex; mode=display']").forEach(function(el) {
              el.outerHTML = "\\[" + el.textContent + "\\]";
            });
            var script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js";
            document.head.appendChild(script);
        }, false);
    </script>
</head>
<body bgcolor="#ffffff" text="#000000">
<h1>David Eppstein - Publications</h1>
<hr><p>
<h2>
Generating multiple near-optimal solutions
</h2>
See also my
<a href="https://www.ics.uci.edu/~eppstein/bibs/kpath.bib">
bibliography of algorithms for <i>k</i> shortest paths</a>, which
also includes related work on other "<i>k</i>th best
solution" problems, especially the <i>k</i> smallest spanning trees.
Victor Jim&eacute;nez and Andr&eacute;s Marzal maintain a web page on
<a href="https://terra.act.uji.es/REA/">algorithms for k shortest paths</a>.
<p>
<ul>
<li><b>Finding the <i>k</i> smallest spanning trees</b>.<br>
D. Eppstein.<br>
<i>2nd Scand. Worksh. Algorithm Theory,</i> Bergen, Norway, 1990.<br>
Springer, <i>Lecture Notes in Comp. Sci.</i> 447, 1990, pp. 38&ndash;47.<br>
<a href="Epp-BIT-92.pdf"><i>BIT</i> 32: 237&ndash;248, 1992</a>
(special issue for 2nd Scand. Worksh. Algorithm Theory).
<p>
By removing edges not involved in some solution,
and contracting edges involved in all solutions,
we reduce the problem to one in a graph with O(<i>k</i>)
edges and vertices.  This simplification step
transforms any time bound involving <i>m</i> or <i>n</i>
to one involving min(<i>m,</i> <i>k</i>) or min(<i>n,</i> <i>k</i>)
respectively.  This paper also introduces the geometric
version of the <i>k</i> smallest spanning trees problem
(the graph version was long known) which it solves using
order (<i>k</i>+1) Voronoi diagrams.
<p>
<li><b>Iterated nearest neighbors and finding minimal polytopes</b>.<br>
D. Eppstein and 
<a href="https://jeffe.cs.illinois.edu/">J. Erickson</a>.<br>
Tech. Rep. 92-71, ICS, UCI, 1992.<br>
<a href="https://portal.acm.org/citation.cfm?id=313612">
<i>4th ACM-SIAM Symp. Discrete Algorithms,</i> Austin, 1993, pp. 64&ndash;73</a>.<br>
<a href="https://jeffe.cs.illinois.edu/pubs/pdf/small.pdf"><i>Disc. Comp. Geom.</i> 11: 321&ndash;350, 1994</a>.
<p>
Showed that for various optimization criteria, the
optimal polygon containing <i>k</i> of <i>n</i>
points must be near one of the points, hence one can transform
time bounds involving several factors of <i>n</i>
to bounds linear in <i>n</i> but polynomial in <i>k.</i>
Used as a subroutine are data structures for finding several
<a href="geom-nn.html">nearest neighbors</a> in rectilinear metric spaces, and
algorithms for finding the
<a href="geom-deep.html">deepest point in an arrangement</a> of cubes or
spheres.
<p>(<a href="https://jeffe.cs.illinois.edu/pubs/small.html">Jeff's pub list entry</a>)
<p>
<li><b>Tree-weighted neighbors and geometric <i>k</i> smallest spanning trees</b>.<br>
D. Eppstein.<br>
<a href="Epp-TR-92-77.pdf">Tech. Rep. 92-77</a>, ICS, UCI, 1992.<br>
<i>Int. J. Comp. Geom. &amp; Appl.</i> 4: 229&ndash;238, 1994.
<p>
"<a href="p-kmst.html">Finding the <i>k</i> smallest spanning trees</a>"
used higher order Voronoi diagrams to reduce the geometric
<a href="kbest.html"><i>k</i> smallest</a>
<a href="mst.html">spanning tree</a> problem to the graph problem.
Here I instead use nearest neighbors for a modified
distance function where the bottleneck shortest path length
is subtracted from the true distance between points.
The result improves the planar time bounds and extends
more easily to higher dimensions.
<p>
<li><b>Ten algorithms for Egyptian fractions</b>.<br>
D. Eppstein.<br>
<i>Mathematica in Education and Research</i> 4 (2): 5&ndash;15, 1995.
<p>
Number theory.
I survey and implement in <i>Mathematica</i> several methods
for representing rational numbers as sums of distinct unit fractions.
One of the methods involves searching for paths in a certain graph
using a <a href="p-kpath.html"><i>k</i> shortest paths</a> heuristic.
<p>(<a href="https://www.ics.uci.edu/~eppstein/numth/egypt/">Also available
in HTML and Mathematica notebook formats</a>)
<p>
<li><b>Sparsification&mdash;A technique for speeding up dynamic graph algorithms</b>.<br>
D. Eppstein,
<a href="https://www.scs.gatech.edu/people/zvi-galil">Z. Galil</a>, 
<a href="https://www.info.uniroma2.it/~italiano/">
G.F. Italiano</a>, and A. Nissenzweig.<br>
<i>33rd IEEE Symp. Foundations of Comp. Sci.,</i> Pittsburgh, 1992, pp. 60&ndash;69.<br>
Tech. Rep. RC 19272 (83907), IBM, 1993.<br>
Tech. Rep. CS96-11, Univ. Ca' Foscari di Venezia, Oct. 1996.<br>
<a href="https://doi.org/10.1145/265910.265914"><i>J. ACM</i> 44 (5): 669&ndash;696, 1997</a>.
<p>
Uses a divide and conquer on the edge set of a graph, together with the
idea of replacing subgraphs by sparser certificates, to make various
dynamic algorithms as fast on dense graphs as they are on sparse graphs.
Applications include random generation of spanning trees
as well as finding the <i>k</i>
<a href="mst.html">minimum weight spanning trees</a>
for a given parameter <i>k.</i>
<p>
<li><b>Improved sparsification</b>.<br>
D. Eppstein,
<a href="https://www.scs.gatech.edu/people/zvi-galil">Z. Galil</a>, and 
<a href="https://www.info.uniroma2.it/~italiano/">
G.F. Italiano</a>.<br>
<a href="EppGalIta-TR-93-20.pdf">Tech. Rep. 93-20</a>, ICS, UCI, 1993.
<p>
Saves a log factor over dynamic graph algorithms in
"<a href="p-sparsification.html">Sparsification</a>"
and their applications, by dividing vertices instead of edges.
Merged into the journal version of "Sparsification".
<p>
<li><b>Separator based sparsification for dynamic planar graph algorithms</b>.<br>
D. Eppstein,
<a href="https://www.scs.gatech.edu/people/zvi-galil">Z. Galil</a>, 
<a href="https://www.info.uniroma2.it/~italiano/">
G.F. Italiano</a>, and T. Spencer.<br>
<a href="https://portal.acm.org/citation.cfm?id=167159"><i>25th ACM Symp. Theory of Computing,</i> San Diego, 1993, pp. 208&ndash;217.</a>
<p>
Replaces portions of a hierarchical separator decomposition with smaller
certificates to achieve fast update times for various dynamic planar graph problems.  Applications include finding the <i>k</i>
<a href="mst.html">best spanning trees</a> of a planar graph.
<p>
<li><b>Separator based sparsification I:
planarity testing and minimum spanning trees</b>.<br>
D. Eppstein,
<a href="https://www.scs.gatech.edu/people/zvi-galil">Z. Galil</a>, 
<a href="https://www.info.uniroma2.it/~italiano/">
G.F. Italiano</a>, and T. Spencer.<br>
<a href="https://doi.org/10.1006/jcss.1996.0002">
<i>J. Comp. Sys. Sci.</i> 52: 3&ndash;27, 1996
(special issue for 25th STOC)</a>.
<p>
First half of journal version of
<a href="p-egis.html">Separator based sparsification for dynamic planar graph algorithms</a>.
<p>
<li><b>Algorithms for proximity problems in higher dimensions</b>.<br>
<a href="https://www.middlebury.edu/~dickerso/">
M. T. Dickerson</a> and D. Eppstein.<br>
<a href="https://doi.org/10.1016/0925-7721(95)00009-7">
<i>Comp. Geom. Theory &amp; Applications</i> 5: 277&ndash;291, 1996</a>.
<p>
Combines a method from
"<a href="p-pgood.html">Provably good mesh generation</a>" for
finding sparse high-dimensional Delaunay triangulations,
a method of Dickerson, Drysdale, and Sack
["<a href="https://www.middlebury.edu/~dickerso/research/enum.html">Simple
algorithms for enumerating interpoint distances</a>", IJCGA 1992]
for using Delaunay
triangulations to search for nearest neighbors,
and a method of Frederickson for speeding up tree-based searches.
The results are fast algorithms for several proximity problems
such as finding the <i>k</i> nearest neighbors to each point
in a given point set.
<p>(<a href="DicEpp-CGTA-96.pdf">Full paper</a>)
<p>
<li><b>Finding the <i>k</i> shortest paths</b>.<br>
D. Eppstein.<br>
<i>35th IEEE Symp. Foundations of Comp. Sci.,</i> Santa Fe, 1994, pp. 154&ndash;165.<br>
<a href="Epp-TR-94-26.pdf">Tech. Rep. 94-26</a>, ICS, UCI, 1994.<br>
<a href="https://doi.org/10.1137/S0097539795290477">
<i>SIAM J. Computing</i> 28 (2): 652&ndash;673, 1998</a>.
<p>
This paper presents an algorithm that finds multiple short paths connecting
two terminals in a graph
(allowing repeated vertices and edges in the paths)
in constant time per path after a preprocessing stage
dominated by a single-source shortest path computation.
The paths it finds are the <i>k</i> shortest in the graph, where <i>k</i> is a
parameter given as input to the algorithm.
<p>
The <i>k</i> shortest paths problem has many important applications for finding
alternative solutions to geographic path planning problems, network
routing, hypothesis generation in computational linguistics, and
sequence alignment and metabolic pathway finding in
bioinformatics. Although there have been many papers on the
<i>k</i> shortest paths problem before and after this one, it has become
frequently cited in those application areas.
Additionally, it marks a boundary in the theoretical study of the problem:
prior theoretical work largely concerned how quickly the problem could
be solved, a line of research that was closed off by the optimal time
bounds of this paper. Subsequent work has focused instead
on devising efficient algorithms for more complex alternative
formulations of the problem that avoid the repeated
vertices and other shortcomings of the alternative paths produced by
this formulation.
<p>
The journal version also includes material from a separate 1995 technical report, "Finding common ancestors and disjoint paths in DAGs".
<p>(<a href="Epp-SJC-98.pdf">Full paper</a> &ndash;
<a href="graehl.zip">Graehl implementation</a> &ndash;
<a href="https://terra.act.uji.es/REA/">Jim&eacute;nez-Marzal implementations</a> &ndash;
<a href="Shibuya.tar.gz">Shibuya implementation</a> &ndash;
<a href="https://www.mat.uc.pt/~eqvm/cientificos/research.html">Martins implementation</a> &ndash;
<a href="https://christophercliff.com/eppstein/">Cliff OpenStreetMap demo</a>)
<p>
<li><b>Representing all minimum spanning trees with applications to
counting and generation</b>.<br>
D. Eppstein.<br>
<a href="Epp-TR-95-50.pdf">Tech. Rep. 95-50</a>, ICS, UCI, 1995.
<p>
Shows how to find for any edge weighted graph G an equivalent
graph EG such that the <a href="mst.html">minimum spanning trees</a>
of G correspond one-for-one with the spanning trees of EG.
The equivalent graph can be
constructed in time O(m+n log n) given a single minimum spanning tree of
G.  As a consequence one can find fast algorithms for counting, listing,
and randomly generating MSTs.
Also discusses similar
equivalent graph constructions for
<a href="graph-path.html">shortest paths</a>, minimum cost flows,
and <a href="graph-match.html">bipartite matching</a>.
<p>
<li><b>Finding common ancestors and disjoint paths in DAGs</b>.<br>
D. Eppstein.<br>
<a href="Epp-TR-95-52.pdf">Tech. Rep. 95-52</a>, ICS, UCI, 1995.
<p>
This paper describes algorithms for finding pairs of vertex-disjoint
paths in a DAG, either connecting two given nodes to a common
ancestor, or connecting two given pairs of terminals.
The main results were merged into the journal version of
"<a href="p-kpath.html">Finding the <i>k</i> shortest paths</a>".
<p>
<li><b>All maximal independent sets and dynamic dominance for sparse
graphs.</b><br>
D. Eppstein.<br>
<a href="https://arxiv.org/abs/cs.DS/0407036">arXiv:cs.DS/0407036</a>.<br>
<i>16th ACM-SIAM Symp. Discrete Algorithms,</i>
Vancouver, 2005, pp. 451&ndash;459.<br>
<a href="https://doi.org/10.1145/1597036.1597042"><i>ACM Trans. Algorithms</i> 5(4):A38, 2009</a>.
<p>
We show how to apply reverse search to list all maximal independent sets
in bounded-degree graphs in constant time per set, in graphs from minor
closed families in linear time per set, and in sparse graphs
in subquadratic time per set.  The latter two results rely on new
data structures for maintaining a dynamic vertex set in a graph
and quickly testing whether the set dominates all other vertices.
<p>
(<a href="Epp-SODA-05-talk.pdf">SODA05 talk slides</a>)
<p>
<li><b><i>k</i>-best enumeration</b>.<br>
D. Eppstein.<br>
<a href="https://doi.org/10.1007/978-3-642-27848-8_733-1"><i>Encyclopedia of Algorithms</i></a> (Ming-Yang Kao, ed.), Springer, added 2014.<br>
<a href="https://arxiv.org/abs/1412.5075">arXiv:1412.5075</a>.<br>
<a href="http://bulletin.eatcs.org/index.php/beatcs/article/view/322"><i>Bull. EATCS</i> 115, 2015</a>.
<p>
A brief survey of algorithms for finding the <i>k</i> shortest paths and
related <i>k</i>-best enumeration problems. The arXiv/EATCS version is
significantly longer and with more references than the Springer version.
<p>
<li><b><i>K</i>-best solutions of MSO problems on tree-decomposable graphs</b>.<br>
D. Eppstein and
<a href="https://ls11-www.cs.uni-dortmund.de/staff/kurz">D. Kurz</a>.<br>
<a href="https://arxiv.org/abs/1703.02784">arXiv:1703.02784</a>.<br>
<i>Proc. 12th International Symposium on Parameterized and Exact
Computation (IPEC 2017)</i>, Vienna, Austria, 2017.<br>
<a href="https://doi.org/10.4230/LIPIcs.IPEC.2017.16">Leibniz International
Proceedings in Informatics (LIPIcs) 89, pp. 16.1&ndash;16.13</a>
<p>
We show that, on graphs of bounded treewidth, for any
optimization problem definable in monadic second-order logic, we can
find the <i>k</i> best solutions in logarithmic time per solution.
<p>
</ul>

<hr><p>
<a href="/~eppstein/pubs/">Publications</a> &ndash;
<a href="/~eppstein/">David Eppstein</a> &ndash;
<a href="/~theory/">Theory Group</a> &ndash;
<a href="/">Inf. &amp; Comp. Sci.</a> &ndash;
<a href="https://www.uci.edu/">UC Irvine</a>
<p>
<small>Semi-automatically <a href="filter.html">filtered</a>
from a common source file.</small>
</body></html>
